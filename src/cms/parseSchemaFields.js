const {
  IGNORE_CMS_TYPES,
  KNOWN_PROP_TYPES,
  OPTIONAL_DESC
} = require('./cmsUtils')

function enhanceField(field) {
  const { type } = field
  // The initial field will only have a description if it's optional
  const isRequired = !field.description

  if (IGNORE_CMS_TYPES.indexOf(type) >= 0) {
    return
  }

  // Check for array and references, which are special cases (ref.subType) || (array.subType)
  const fieldParts = type.split('.')
  if (fieldParts.length > 1) {
    const REF_ALIASES = ['reference', 'ref']
    if (fieldParts[0] === 'array') {
      const childType =
        // We can have an array of references (array.ref.subType)
        REF_ALIASES.indexOf(fieldParts[1]) >= 0
          ? { type: fieldParts[1], to: [{ type: fieldParts[2] }] }
          : { type: fieldParts[1] }
      field = {
        ...field,
        type: 'array',
        of: [childType]
      }
      if (isRequired) {
        field._validation = {
          type: 'array',
          props: {
            min: 1
          }
        }
      }
    } else if (REF_ALIASES.indexOf(fieldParts[0]) >= 0) {
      field = {
        ...field,
        type: 'reference',
        to: [{ type: fieldParts[1] }]
      }
      if (isRequired) {
        field._validation = {
          type: 'default'
        }
      }
    } else {
      // If a 2+ part type that is not an array or ref, return empty
      return
    }
  }

  // Better titles for editors
  if (field.name === 'title' && field.title === 'title') {
    field.title = 'TÃ­tulo'
  }

  // Validation
  if (isRequired) {
    if (['string', 'text'].indexOf(type) >= 0) {
      field._validation = {
        type: 'text'
      }
    } else if (type === 'url') {
      field._validation = {
        type: 'url'
      }
    } else {
      field._validation = {
        type: 'default'
      }
    }
  }

  return field
}

function getFieldsFromChild(child) {
  const { cmsType, propName, htmlTag, originalName, isRequired } = child._meta

  // In case we don't have a cmsType but have a propName, check if it's one of the known prop types, in which case we can regard it
  const typeFromProp = KNOWN_PROP_TYPES[propName]

  let field = {
    title: originalName || propName,
    name: propName,
    type: cmsType || typeFromProp
  }

  // Add the optional description if not required
  if (!isRequired) {
    field.description = OPTIONAL_DESC
  }

  if (field.type) {
    field = enhanceField(field)
    return field
  }

  // If we don't have a propName nor a cmsType, then we might be dealing with a wrapper UI-only component. Dig into its children.
  if (!cmsType && !propName && child.children) {
    const childrenFields = child.children.map(getFieldsFromChild)
    return childrenFields
  }
  // If none of these conditions are met, return nothing
  return
}

module.exports = function(node) {
  let props = {
    type: node._meta.cmsType,
    name: node._meta.camelCasedName,
    title:
      node.description || node._meta.originalName || node._meta.camelCasedName,
    fields: []
  }
  props.fields = node.children
    .map(getFieldsFromChild)
    // Flat all of the children's nested fields (100 is a large enough number to flat everything)
    .flat(100)
    // Remove undefineds generated by getFieldsFromChild
    .filter(child => !!child)
  return props
}
